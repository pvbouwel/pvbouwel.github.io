<!doctype html><html lang=en><head><title>Serialization Anomily when using MVCC (The good, the bad & the ugly) · Allinthemiddle</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="pvbouwel"><meta name=description content="In-depth walkthroug of serialization anomily when MVCC is used by the Database implementation."><meta name=keywords content="blog,devops,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Serialization Anomily when using MVCC (The good, the bad & the ugly)"><meta name=twitter:description content="In-depth walkthroug of serialization anomily when MVCC is used by the Database implementation."><meta property="og:url" content="http://pvbouwel.github.io/posts/serialization-anomyly-for-mvcc/"><meta property="og:site_name" content="Allinthemiddle"><meta property="og:title" content="Serialization Anomily when using MVCC (The good, the bad & the ugly)"><meta property="og:description" content="In-depth walkthroug of serialization anomily when MVCC is used by the Database implementation."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-03T13:34:35+02:00"><meta property="article:modified_time" content="2021-12-03T13:34:35+02:00"><meta property="article:tag" content="Databases"><meta property="article:tag" content="Serialization"><link rel=canonical href=http://pvbouwel.github.io/posts/serialization-anomyly-for-mvcc/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.6445a802b9389c9660e1b07b724dcf5718b1065ed2d71b4eeaf981cc7cc5fc46.css integrity="sha256-ZEWoArk4nJZg4bB7ck3PVxixBl7S1xtO6vmBzHzF/EY=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/img/favicon.svg sizes=any><link rel=icon type=image/png href=/img/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/img/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=http://pvbouwel.github.io/>Allinthemiddle
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=http://pvbouwel.github.io/posts/serialization-anomyly-for-mvcc/>Serialization Anomily when using MVCC (The good, the bad & the ugly)</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2021-12-03T13:34:35+02:00>December 3, 2021
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
10-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/databases/>Databases</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/serialization/>Serialization</a></span></div></div></header><div class=post-content><h2 id=intro>Intro
<a class=heading-link href=#intro><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>When working in-depth with databases sooner or later you will encounter transaction isolation levels. If you are new to transaction isolation check out the <a href=https://www.postgresql.org/docs/9.5/transaction-iso.html class=external-link target=_blank rel=noopener>Postgress transaction isolation documentation</a> because that documentation team did an amazing job! In this post I&rsquo;d like to go into more depth on one issue mentioned on that page the serialization anomaly.</p><h2 id=real-life-example>Real life example
<a class=heading-link href=#real-life-example><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>A picture says more than a thousands words so let&rsquo;s try to create a mental picture by talking about a real-life scenario. For this assume we are creating an application that has to manage financial accounts.</p><p>Let&rsquo;s take as a starting point 3 accounts with the following balances:</p><pre><code>Account A: €20
Account B: €30
Account C: €40
</code></pre><p>Now consider 2 transaction:</p><pre><code>tx1: transfers money (€10) from account A to a account B
tx2: transfers money (€10) from account A to C
</code></pre><p>In order to perform these transactions against our database engine it is required to read the balance of the sender from the balances table , subtract the amount sent and write the new balance. Subsequently it needs to read the balance of the receiver, add the amount and write the receiver&rsquo;s new balance.</p><p>When these transactions happen in a non-overlapping mode performing these changes to your data is almost trivial. We can detail the steps as follows: <strong>Transaction 1 is in bold</strong> and transaction 2 in italics. Then the statements look like:</p><p><strong>Begin - RA - WA - RB - WB - end</strong> - <em>begin - RA - WA - RC - WC - end</em></p><p>So in detail:</p><ul><li><strong>begin</strong> : begins the first transaction</li><li><strong>RA</strong> : reads balance for account A 20 euro</li><li><strong>WA</strong> : write the new balance of 10 Euro for account A</li><li><strong>RB</strong>: reads balance for account B 30 euro</li><li><strong>WB</strong>: write new balance of 40 euro for account B</li><li><strong>end</strong>: ends the first transaction</li><li><em>begin</em>: begins the second transaction</li><li><em>RA</em>: reads balance for account A 10 euro (since previous change is committed)</li><li><em>WA</em>: writes the new balance of 0 euro for account A</li><li><em>RC</em>: reads balance for account C 40 euro</li><li><em>WC</em>: writes the new balance of 50 euro for account C</li><li><em>end</em>: ends the second transaction</li></ul><p>These steps should be intuitive and feel familiar as it is the behavior we expect when performing financial transactions in real life.</p><p>The reason why this is easy is because concurrency in this example always 1, a single transaction is in the system, so no overlap is taking place.</p><h1 id=the-interesting-world-of-concurrency>The interesting world of concurrency
<a class=heading-link href=#the-interesting-world-of-concurrency><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Just like a puzzle becomes more interesting when getting to more than 1 piece concurrency becomes interesting when having multiple concurrent actors.</p><p>A modern database however will have a few tricks up its sleeves to manage concurrency. Locking is probably the best-known mechanism to deal with concurrency. It can for example avoid data corruption due to multiple processes writing the same record at the same time. Locking is very powerful but is generally not the first choice to deal with concurrency because it causes contention which lowers the throughput of your database system. Which brings us to another database trick; <a href=https://www.postgresql.org/docs/9.5/mvcc-intro.html class=external-link target=_blank rel=noopener>Multiversion Concurrency Control</a>, MVCC in short.</p><p>MVCC is an implementation where each transaction will get a snapshot of the database state at transaction start. This allows the DB engine to be able to read data without risking a dirty read. So it avoids reading of uncommitted data even when that data is changed by another concurrent process. It also enables repeatable reads. It can however cause Serialization anomalies which would make scenario&rsquo;s possible that don&rsquo;t make sense in real life. In order to understand why this is a problem let&rsquo;s revisit our 2 example transactions. Let&rsquo;s start with our system initialized again on the starting point detailed earlier but this time let&rsquo;s have the transactions executed concurrently such that the different statements within them are interleaved.</p><p>Assume the order:</p><p><strong>Begin</strong> - <strong>RA</strong> - <em>begin</em> - <em>RA</em> - <strong>WA</strong> - <strong>RB</strong> - <strong>WB</strong> - <strong>end</strong> - <em>WA</em> - <em>RC</em> - <em>WC</em> - <em>end</em></p><p>So in detail:</p><ul><li><strong>begin</strong>: begins the first transaction</li><li><strong>RA</strong>: reads balance for account A 20 euro</li><li><em>begin</em>: begins the second transaction</li><li><em>RA</em>: reads balance for account A 20 euro (since previous change is not committed and when transaction started the snapshot of the database had still the original balance of 20 euro for account A)</li><li><strong>WA</strong>: write the new balance of 10 Euro for account A</li><li><strong>RB</strong>: reads balance for account B 30 euro</li><li><strong>WB</strong>: write new balance of 40 euro for account B</li><li><strong>end</strong>: ends the first transaction</li><li><em>WA</em>: writes the new balance of 10 euro for account A (since this transaction also read the 20 euro starting balance due to MVCC and subtracted 10 from it)</li><li><em>RC</em>: reads balance for account C 40 euro</li><li><em>WC</em>: writes the new balance of 50 euro for account C</li><li><em>end</em>: ends the second transaction</li></ul><p>This is a serialization anomaly and this example hopefully illustrated why this is a problem. If it is unclear imagine you are a bank managing these accounts. Your system has just generated money for your customer who could withdraw or use that money! The above scenario is well possible if you picture an account with multiple users. Two different users could easily wire money to different accounts concurrently around the same time. So for these type of workloads it is important to avoid serialization anomalies.</p><h1 id=serializable-isolation-to-the-rescue>Serializable isolation to the Rescue
<a class=heading-link href=#serializable-isolation-to-the-rescue><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>It is possible to avoid serialization anomalies in database engines that allow running with the strictest transaction isolation level; serializable isolation.</p><p>Serializable isolation states that in order for a concurrent execution of transactions to be valid a serial ordering of transactions has to exist such that each statement execution has the same results as in the concurrent execution.</p><p>So if we start from our concurrent execution in our example. Since there are 2 transactions we have 2 possible orderings:</p><pre><code>Tx1 followed by Tx2
Tx2 followed by Tx1
</code></pre><p>Or in our per statement illustration:</p><ul><li><strong>begin - RA - WA - RB - WB - end</strong> - <em>begin - RA - WA - RC - WC - end</em></li><li><em>begin - RA - WA - RC - WC - end</em> - <strong>begin - RA - WA - RB - WB - end</strong></li></ul><p>I leave it to the reader to detail the outcomes of the second ordering. You should arrive to the conclusion that account A will always have a balance of 0 after both transactions finish no matter how you order these 2 transactions (serially). Therefore if you have a database engine running in transaction level serializable isolation and you try to do the concurrent execution then that engine will give an error. This does not mean there is an issue in the Database engine but rather that there is a problem with your workload. If it occurs rarely it&rsquo;s possible to just have your application catch these exceptions and retry. Because when this error is thrown generally the database engine will rollback 1 of the transactions, often the transaction that submitted the statement that would give rise to the anomaly.</p><h1 id=how-can-the-db-know>How can the DB know?
<a class=heading-link href=#how-can-the-db-know><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>There is no such thing as magic (not even in the database world) so the engine must have some clever way of detecting that a statement would cause a serialization anomaly. Working backwards from the behavior of serially ordered transactions you could come op with 2 rules:</p><pre><code>1. If data is read in a transaction TX that was written by another transaction
   TC which was committed before the start of Tx then in a sequential ordering
   Tx must follow TC (order: TC -&gt; TX)
2. If data is read in a transaction TY that is written by another transaction 
   that overlaps but wasn't committed when TY started then Ty must precede TU
   (order TY -&gt; TU) 
</code></pre><p>Note that</p><ul><li>Data read and written within the same transaction doesn&rsquo;t impose ordering</li><li>2 Reads from different transactions also don&rsquo;t impose an ordering</li><li>Since more than 2 transactions can overlap a read-only transaction could still give rise to a serialization anomaly!</li></ul><p>In concurrent executions that are a serialization anomaly you will get ordering rules that will be in conflict. For our example:</p><p><strong>Begin - RA</strong> - <em>begin - RA</em> - <strong>WA - RB - WB - end</strong> - <em>WA - RC - WC - end</em></p><ul><li><strong>begin</strong>: begins the first transaction</li><li><strong>RA</strong>: reads balance for account A</li><li><em>begin</em>: begins the second transaction</li><li><em>RA</em>: reads balance for account A<ul><li>2 reads don&rsquo;t impose ordering between each other</li></ul></li><li><strong>WA</strong>: write the new balance of account A<ul><li>At this point the DB knows that <em>T2</em> reads data written to by an overlapping transaction <strong>T1</strong> which is uncommitted so <em>T2</em> must precede <strong>T1</strong> (<em>T2</em> -> <strong>T1</strong> )</li></ul></li><li><strong>RB</strong>: reads balance for account B</li><li><strong>WB</strong>: write new balance for account B</li><li><strong>end</strong>: ends the first transaction</li><li><em>WA</em>: writes the new balance for account A<ul><li>Now the DB knows that <strong>T1</strong> reads data written by <em>T2</em> which was not committed at starttime of <strong>T1</strong> so <strong>T1</strong> has to precede <em>T2</em> (<strong>T1</strong> -> <em>T2</em>)</li></ul></li></ul><p>At this stage the DB engine can throw an exception as no matter what happens further with <em>T2</em> (except for a transaction rollback) it will yield a serialization anomaly. Therefore it is best to rollback the transaction immediately and don&rsquo;t allow further statements as their results shouldn&rsquo;t be relied upon anyway.</p><p>The advantage of the arrow notation is that you can chain them together and as soon as you encounter a transaction for a second time you know there is a violation. So if we chain them in the order we found them:</p><p>(<em>T2</em> -> <strong>T1</strong> ) || (<strong>T1</strong> -> <em>T2</em>) => (<em>T2</em> -> <strong>T1</strong> -> <em>T2</em>)</p><p>A directed graph would be a useful way of tracking these orderings discovered by applying the rules. Cycles would in this case indicate a serialization anomaly so we can use a directed acyclic graph (DAG).</p><h1 id=in-summary>In summary
<a class=heading-link href=#in-summary><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>Transactions should see the database as if they were running alone on the system, not being impacted by other running transactions. This is important because we don&rsquo;t know what will happen to these transactions, they could be aborted and in that case relying on the data written by them would cause an anomaly in itself. Ironically it is the measures we put in place to protect against these anomalies that could give rise to a serialization anomaly where results from statements of overlapping transactions wouldn&rsquo;t be retrievable if the transactions had happened serially. This post showcases that for MVCC and aims at providing intuition into why these serialization anomalies are problematic and give basic insights in what a database can do to protect you from it. That is if you chose to run with a transaction level of serializable isolation.</p><h1 id=final-notes>Final Notes:
<a class=heading-link href=#final-notes><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h1><p>I haven&rsquo;t gone into much detail about locking. Locking can be used to avoid serializable isolation anomalies but it requires aggressive locks (e.g. exclusive locks) that would enforce serial access to the underlying resource. The example is chosen in such a way that the concurrent execution would be possible even with table level locking. For example where during normal database execution writes would block other writes. This is because locks follow the lifetime of a transaction and <strong>T1</strong> ended before a write in <em>T2</em> could give rise to contention on a lock.</p><p>I have tried to give a simple explanation for the tracking mechanism above. Note that my example covered only rule 2. Rule 2 is easiest to track as you only need to take into account open transactions. Rule 1 on the other hand uses committed transactions which is troublesome to track since their amount grows with the uptime of your database. You can stop keeping track of committed transactions from the moment they no longer have (direct or indirect) overlap with open transactions. This overlap could disappear because transactions can close (by commit or rollback). But a lot of database instances have a continuous workload which could block this type of cleanup since there always remains overlap with open transactions. The good news is that research exists which investigates use of heuristics to efficiently avoid serialization anomalies. A nice and freely available paper on such a heuristic is &ldquo;<a href=https://arxiv.org/abs/1605.04292 class=external-link target=_blank rel=noopener>Efficiently making (almost) any concurrency control mechanism serializable</a>&rdquo;.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2009 -
2025
pvbouwel
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>